# 第04章 逻辑架构

## 1. 逻辑架构剖析

首先MySQL是典型的C/S架构，即`Client/Server 架构`，服务器端程序使用的是 `mysqld`。

不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：**客户端进程向服务器进程发送一段文本（SQL 语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）**。

那么服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：

### 1.1 服务器处理客户端请求

<img src=".\images\Logical_Architecture.jpg" alt="Logical_Architecture" style="zoom: 67%;" />

![Logical_Architecture2](.\images\Logical_Architecture2.jpg)

![Logical_Architecture3](.\images\Logical_Architecture3.png)

### 1.2 Connectors

Connectors，指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL,我们可以编写代码，跟MySQL Server`建立TCP连接`，之后按照其定义好的协议进行交互。或者比较方便的办法是调用SDK,比如Native C API、JDBC、PHP等各语言MySQL Connector,或者通过ODBC。**通过SDK来访问MySQL,本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互。**

### 1.3 第1层：连接层

**连接管理**的职责是**负责认证、管理连接、获取权限信息**。

系统（客户端）访问`MySQL`服务器前，做的第一件事就是建立`TCP`连接。

经过三次握手建立连接成功后，`MySQL`服务器对`TCP`传输过来的账号密码做身份认证、权限获取。

- **用户名或密码不对**，会收到一个`Access denied for user`错误，客户端程序结束执行
- **用户名密码认证通过**，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限

<img src=".\images\MySQLConnection.png" alt="MySQLConnection" style="zoom:100%;" />

<b>TCP连接池</b>

多个系统都可以和MySQL服务器建立连接，每个系统建立的连接不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL服务器里有专门的`TCP连接池`限制连接数采用`长连接模式`复用TCP连接，来解决上述问题。

<b>线程池</b>

`TCP`连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。

这些内容我们都归纳到`MySQL`的**连接管理**组件中。

### 1.4 第2层：服务层

第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成`缓存的查询`，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。

在该层，服务器会`解析查询`并创建相应的内部`解析树`，并对其完成相应的`优化`：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。

如果是SELECT语句，服务器还会`查询内部的缓存`。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

| 组件名                            | 解释                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `Management Services & Utilities` | 系统管理和控制工具                                           |
| `SQL Interface`                   | SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface。 |
| `Parser`                          | SQL 解析器。SQL 命令传递到解析器的时候会被解析器验证和解析。 |
| `Optimizer`                       | SQL 查询优化器。SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。 |
| `Cache & Buffer`                  | SQL 查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。 |

- **SQL Interface: SQL接口**

  - 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ... FROM就是调用SQL Interface 
  - MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口

- **Parser:** **解析器**

  - 在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。
  - 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建`语法树`，并根据数据字典丰富查询语法树，会`验证该客户端是否具有执行该查询的权限`。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。

- **Optimizer:** **查询优化器**

  - SQL语句在语法解析之后、查询之前会使用查询优化器确定SQL语句的执行路径，生成一个`执行计划`。
  - 这个执行计划表明应该`使用哪些索引`进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。
  - 它使用“`选取-投影-连接`”策略进行查询。例如：

  ```mysql
  SELECT id,name FROM student WHERE gender = '女';
  ```

  这个SELECT查询先根据WHERE语句进行`选取`，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性`投影`，而不是将属性全部取出以后再进行过滤，将这两个查询条件`连接`起来生成最终查询结果。

- **Caches & Buffers： 查询缓存组件**

  - MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。
  - 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。
  - 这个查询缓存可以在`不同客户端之间共享`。 
  - 从MySQL 5.7.20开始，不推荐使用查询缓存，并在`MySQL 8.0中删除`。

### 1.5 第3层：引擎层

插件式存储引擎层（ Storage Engines）**真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作**，服务层通过API与存储引擎进行通信。

`插件式的存储引擎`架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MySQL还允许`开发人员设置自己的存储引擎`。

`MySQL 8.0.25` 默认支持的存储引擎如下

```mysql
show engines;
```

<img src=".\images\engines.png" alt="engines"  />

### 1.6 存储层

所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在`文件系统`上，以`文件`的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。

### 1.7 小结

简化为三层结构：

* 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；

* SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；

* 存储引擎层：与数据库文件打交道，负责数据的存储和读取。

## 2. SQL执行流程

### 2.1 MySQL中的SQL执行流程

![SQL_Execution_Flow](.\images\SQL_Execution_Flow.jpg)

**MySQL的查询流程：**

#### 1）查询缓存

Server如果在查询缓存中发现了这条SQL语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在MySQL8.0之后就抛弃了这个功能。

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。`之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中`。key是查询的语句，value是查询的结果。如果查询能够直接在这个缓存中找到key,那么这个value就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。`执行完成后，执行结果会被存入查询缓存中`。所以，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

**1.1) 大多数情况查询缓存就是个鸡肋，为什么呢？**

查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。

需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的`鲁棒性大大降低`，只有`相同的查询操作才会命中查询缓存`。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此MySQL的`查询缓存命中率不高`。

> 鲁棒性（Robustness）是指系统、程序或算法在面临不确定性、异常情况或错误输入时，依然能够正确运行或保持一定性能的能力。

同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数`NOW`，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！

此外，既然是缓存，那就有它`缓存失效的时候`。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了`INSERT`、`UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或`DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于`更新压力大的数据库`来说，查询缓存的命中率会非常低。

**总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。**

**1.2) 查询缓存的使用建议**

一般建议在静态表里使用查询缓存，什么叫`静态表`呢？就是一般极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。好在MySQL也提供了这种“`按需使用`”的方式。你可以将`my.cnf`参数`query_cache_type`设置成`DEMAND`,代表当sql语句中有`SQL_CACHE`关键词时才缓存。比如：

```properties
#query_cache_type有3个值 0代表关闭查询缓存OFF,1代表开启ON,2(DEMAND)
query_cache_type=2
```

这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用`SQL_CACHE`显式指定，像下面这个语句一样：

```mysql
SELECT SQL_CACHE column1, column2, ...
FROM table_name
WHERE condition;
```

如果缓存处于开启，也可以使用`SQL_NO_CACHE`来显示指明不使用缓存

<b>查看当前mysq实例是否开启缓存机制</b>

```mysql
# MySQL5.7中
mysql> show variables like 'query_cache_type';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_type | OFF   |
+------------------+-------+

# MySQL8.0中
mysql> show global variables like 'query_cache_type';
Empty set (0.00 sec)
```

<b>监控查询缓存的命中率</b>

```mysql
mysql> show status like '%Qcache%';
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| Qcache_free_blocks      | 1       |
| Qcache_free_memory      | 1031832 |
| Qcache_hits             | 0       |
| Qcache_inserts          | 0       |
| Qcache_lowmem_prunes    | 0       |
| Qcache_not_cached       | 1       |
| Qcache_queries_in_cache | 0       |
| Qcache_total_blocks     | 1       |
+-------------------------+---------+
```

运行结果解析：

- `Qcache_free_blocks`:表示查询缓存中还有多少剩余的blocks,如果该值显示较大，则说明查询缓存中的`内存碎片`过多了，可能在一定的时间进行整理。
- `Qcache_free_memory`:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。
- `Qcache_hits`:表示有`多少次命中缓存`。可以通过该值来验证查询缓存的效果。数字越大，缓存效果越理想。
- `Qcache_inserts`:表示`多少次未命中然后插入`，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。
- `Qcache_lowmem_prunes`:该参数记录`有多少条查询因为内存不足而被移除出查询缓存`。通过这个值，用户可以适
  当的调整缓存大小。
- `Qcache_not_cached`:表示因为`query_cache_type`的设置而没有被缓存的查询数量。
- `Qcache_queries_in_cache`:当前缓存中`缓存的查询数量`。
- `Qcache_total_blocks`:当前缓存的block数量。



#### 2）解析器

**在解析器中对SQL语句进行语法分析、语义分析。**

如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。SQL语句的分析分为词法分析与语法分析。

分析器先做`词法分析`。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 

MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。

接着，要做“`语法分析`”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否`满足 MySQL 语法`。

如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。

如果SQL语句正确，则会生成一个语法树

<img src=".\images\syntax_tree.png" alt="syntax_tree" style="zoom:100%;" />



下图是SQL词法分析的步骤过程

![parser](.\images\parser.png)

至此解析器的工作任务也基本圆满了。接下来进入到优化器。



#### 3）优化器

<b>优化器的作用</b>

在优化器中会确定SQL语句的执行路径，比如是根据`全表检索`，还是根据`索引检索`等。

经过了解析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。**一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。**

比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join)的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。

举例：如下语句是执行两个表的join:

```mysql
select * from test1 join test2 using(ID)
where test1.name='zhangsan'and test2.name='mysql高级课程';
```

```
方案1：可以先从表test1里面取出name=’zhangwei’的记录的ID值，再根据ID值关联到表test2,再判断test2里面name的值是否等于’mysql高级课程’。

方案2：可以先从表test2里面取出name=’mysq1高级课程’的记录的ID值，再根据ID值关联到test1,再判断test1里面name的值是否等于zhangwei。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈
```

<b>逻辑查询优化和物理查询优化</b>

在查询优化器中，可以分为`逻辑查询优化`阶段和`物理查询优化`阶段。

逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行`等价变换`，对查询进行`重写`，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。

物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地`使用索引`，提升查询效率。



#### 4）执行器

在执行之前需要判断该用户是否`具备权限`。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在MySQL8.0以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎`API`对表进行的读写。存储引擎`API`只是抽象接口，下面还有个**存储引擎层**，具体实现还是要看表选择的存储引擎。

```mysql
select * from test where id=1;
```

比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：

```
调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；
调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
```



#### 5）小结

SQL语句在MySQL中的流程是：`SQL语句→查询缓存→解析器→优化器→执行器`。

![SQL_EXECUTION_FLOW2](.\images\SQL_EXECUTION_FLOW2.png)



### 2.2 MySQL8中SQL执行分析

一条SQL语句会经历不同的模块，在不同的模块中，SQL执行所使用的资源（时间）不同。

下面通过命令行分析SQL语句的执行经过的模块和占用的时间。

<b>1) 查看profiling 是否开启</b>

```mysql
select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+

show variables like 'profiling';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| profiling     | OFF   |
+---------------+-------+
```

profiling=0 代表关闭，需要把 profiling 打开，即设置为 1：

```mysql
set profiling=1;
```

<b>2) 多次执行相同SQL查询</b>

```mysql
select * from employees;
```

<b>3) 查看profiles</b>

```mysql
show profiles; # 显示最近的几次查询
+----------+------------+---------------------------------+
| Query_ID | Duration   | Query                           |
+----------+------------+---------------------------------+
|        1 | 0.00189200 | show variables like 'profiling' |
|        2 | 0.00020325 | SELECT DATABASE()               |
|        3 | 0.00064575 | show databases                  |
|        4 | 0.00051400 | show tables                     |
|        5 | 0.00125675 | show tables                     |
|        6 | 0.00047500 | select * from employees         |
|        7 | 0.00054475 | select * from employees         |
+----------+------------+---------------------------------+
```

<b>4) 查看profile</b>

显示执行计划，查看程序的执行步骤

```mysql
# 默认查询最后一次的执行过程(show profiles返回的Query_ID为7)
show profile;
# 查询指定的 Query ID
show profile for query 7;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000103 |
| Executing hook on transaction  | 0.000010 |
| starting                       | 0.000010 |
| checking permissions           | 0.000008 |
| Opening tables                 | 0.000044 | 
| init                           | 0.000006 | 
| System lock                    | 0.000010 |
| optimizing                     | 0.000004 |
| statistics                     | 0.000023 |
| preparing                      | 0.000022 |
| executing                      | 0.000238 |
| end                            | 0.000004 |
| query end                      | 0.000004 |
| waiting for handler commit     | 0.000009 |
| closing tables                 | 0.000008 |
| freeing items                  | 0.000030 |
| cleaning up                    | 0.000012 |
+--------------------------------+----------+
```

* `checking permissions` 权限检查
* `Opening tables ` 打开表
* `init` 初始化
* `System lock` 锁系统
* `optimizing` 优化查询
* `preparing` 准备
* `executing` 执行

```mysql
# 查询更丰富的内容
show profile cpu,block io for query 6;
```

除了查看cpu、io阻塞等参数情况，还可以查询下列参数的利用情况

```mysql
Syntax:
SHOW PROFILE [type [, type] ... ]
	[FOR QUERY n]
	[LIMIT row_count [OFFSET offset]]

type: {
	| ALL -- 显示所有参数的开销信息
	| BLOCK IO -- 显示IO的相关开销
	| CONTEXT SWITCHES -- 上下文切换相关开销
	| CPU -- 显示CPU相关开销信息
	| IPC -- 显示发送和接收相关开销信息
	| MEMORY -- 显示内存相关开销信息
	| PAGE FAULTS -- 显示页面错误相关开销信息
	| SOURCE -- 显示和Source_function,Source_file,Source_line 相关的开销信息
	| SWAPS -- 显示交换次数相关的开销信息
}
```

### 2.3 MySQL5.7中SQL执行分析

在MySQL5.7中测试，`显式开启查询缓存模式`。

<b>1）在`/etc/my.cnf`配置文件中开启查询缓存</b>

```properties
query_cache_type=1
```

<b>2）重启服务器</b>

```bash
systemctl restart mysqld
```

<b>3）开启查询执行计划</b>

```mysql
set profiling=1;
```

<b>4）执行语句两次</b>

```mysql
select * from employees;
select * from employees;
```

<b>5）查看profiles</b>

```mysql
mysql> show profiles;
+----------+------------+-------------------------+
| Query_ID | Duration   | Query                   |
+----------+------------+-------------------------+
|        1 | 0.00058175 | select * from employees |
|        2 | 0.00009325 | select * from employees |
+----------+------------+-------------------------+
```

<b>6）查看profile</b>

```mysql
mysql> show profile for query 1;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000037 |
| Waiting for query cache lock   | 0.000004 |
| starting                       | 0.000002 |
| checking query cache for query | 0.000087 |
| checking permissions           | 0.000009 |
| Opening tables                 | 0.000020 |
| init                           | 0.000025 |
| System lock                    | 0.000009 |
| Waiting for query cache lock   | 0.000002 |
| System lock                    | 0.000018 |
| optimizing                     | 0.000004 |
| statistics                     | 0.000013 |
| preparing                      | 0.000012 |
| executing                      | 0.000003 |
| Sending data                   | 0.000259 |
| end                            | 0.000004 |
| query end                      | 0.000007 |
| closing tables                 | 0.000008 |
| freeing items                  | 0.000007 |
| Waiting for query cache lock   | 0.000002 |
| freeing items                  | 0.000028 |
| Waiting for query cache lock   | 0.000003 |
| freeing items                  | 0.000002 |
| storing result in query cache  | 0.000003 |
| cleaning up                    | 0.000016 |
+--------------------------------+----------+

mysql> show profile for query 2;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000043 |
| Waiting for query cache lock   | 0.000003 |
| starting                       | 0.000002 |
| checking query cache for query | 0.000005 |
| checking privileges on cached  | 0.000003 |
| checking permissions           | 0.000011 |
| sending cached result to clien | 0.000022 |
| cleaning up                    | 0.000005 |
+--------------------------------+----------+
```

**从结果中可以看出查询语句直接从缓存中获取数据。**

## 3. 数据库缓冲池(buffer pool)

`InnoDB`存储引擎是以页为单位来管理存储空间的，增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I/O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请`占用内存来作为数据缓冲池`，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的`Buffer Pool`之后才可以访问。

这样做的好处是可以让磁盘活动最小化，从而`减少与磁盘直接进行I/O的时间`。这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。

### 3.1 缓冲池 vs 查询缓存

**1）缓冲池（Buffer Pool）**

在InnoDB存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存

InnoDB缓冲池包括了数据页、索引页、插入缓存、锁信息、自适应Hash和数据字典信息等。

<b>缓存池的重要性：</b>

对于使用`InnoDB`作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以`页`的形式存放在`表空间`中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上`“快如风，疾如电"的CPU`呢？这里，缓冲池可以帮助我们消除CPU和磁盘之间的`鸿沟`。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把`完整的页的数据全部加载到内存`中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其`缓存`起来，这样将来有请求再次访问该页面时，就可以`省去磁盘IO的开销`了。

<b>缓存原则：</b>

“`位置 * 频次`”这个原则，对I/O访问效率进行优化。

首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。

其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会`优先对使用频次高的热数据进行加载`。

<b>缓冲池的预读特性:</b>

缓冲池的作用就是提升 I/O 效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，**大概率还会使用它周围的一些数据**，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 I/O 操作。

**2）查询缓存**

查询缓存是提前把`查询结果缓存`起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会效，因此命中率低。

缓冲池服务于数据库整体的/O操作，它们的共同点都是通过缓存的机制来提升效率。

### 3.2 缓冲池如何读取数据

缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。

缓存在数据库中的结构和作用如下图所示：

<img src=".\images\Buffer_Pool.png" alt="Buffer_Pool" style="zoom: 80%;" />

**如果我们执行SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？**

实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会`以一定的频率刷新`到磁盘中。注意并不是每次发生更新操作，都会立即进行磁盘回写。缓冲池会采用一种叫做 `checkpoint 的机制` 将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。

比如，当`缓冲池不够用`时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上，然后再从缓存池中将这些页释放掉。这里的脏页 (dirty page) 指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。

### 3.3 查看/设置缓冲池的大小

Mysql MyISAM存储引擎只缓存索引，不缓存数据，对应的键缓存参数为`key_buffer_size`

InnoDB存储引擎，可以通过查看`innodb_buffer_pool_size`变量来查看缓冲池的大小。

<b>查看缓冲池的大小</b>

```mysql
show variables like 'innodb_buffer_pool_size';
+-------------------------+-----------+
| Variable_name           | Value     |
+-------------------------+-----------+
| innodb_buffer_pool_size | 134217728 |
+-------------------------+-----------+
```

此时InnoDB的缓冲池大小是`134217728/1024/1024=128MB`

<b>设置缓冲池的大小</b>

```mysql
set global innodb_buffer_pool_size = 268435456;
```

或者

```ini
[server] 
innodb_buffer_pool_size = 268435456
```

### 3.4 多个Buffer Pool实例

Buffer Pool本质是 InnoDB 向操作系统申请的一块`连续的内存空间`，在多线程环境下，访问Buffer Pool中的数据都需要`加锁`处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，可以把它们`拆分成若干个小的Buffer Pool`，每个Buffer Pool都称为一个`实例`，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。

可以在服务器启动的时候通过设置`innodb_buffer_pool_instances`的值来修改Buffer Pool实例的个数

```ini
[server] 
innodb_buffer_pool_instances = 2
```

表明创建2个 `Buffer Pool` 实例

查看缓冲池的个数

```mysql
show variables like 'innodb_buffer_pool_instances';
```

每个`Buffer Pool`实例实际占内存空间

```
innodb_buffer_pool_size/innodb_buffer_pool_instances
```

总共的大小除以实例的个数，结果就是每个`Buffer Pool`实例占用的大小。



不过也不是说 Buffer Pool 实例创建的越多越好，分别`管理各个Buffer Pool也是需要性能开销的`，InnDB规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances的值修改为1。建议在 Buffer Pool 大于等于1G的时候设置多个Buffer Pool实例。

### 3.5 引申问题

Buffer Pool是MySQL内存结构中十分核心的一个组成，可以先把它想象成一个黑盒子

**黑盒下的更新数据流程**

查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先数据加载进来，然后修改内存的数据。被修改的数据会在之后统一刷入磁盘。

<img src=".\images\Buffer_Pool_Problem.jpg" alt="Buffer_Pool_Problem" style="zoom:100%;" />

这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MySQL宕机了，这部分数据将会永久地丢失；

再者，更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？

答案：**Redo Log** & **Undo Log**
